# 일일회고

### 6월 11일

#### 점근적 복잡도
시간 복잡도와 공간복잡도에 관해 배움. 시간복잡도는 간략하게 말하면 입력값과 문제를 해결하는데 걸리는 시간과의 상관관계를 말하고, 공간 복잡도는 입력값과 문제를 해결하는 데 걸리는 공간과의 상관관계를 말함.
시간복잡도를 대체로 더 중요하게 여기고 입력값이 많아져도 걸리는 시간이 덜 늘어나는 알고리즘이 좋은 알고리즘이 될 수 있다고 함. 아닐수도 있고

#### Array | Linked List
Array는 배열이고 특정 원소를 조회하는 경우에 사용하는 것이 유리하고 LinkedList는 중간에 데이터를 삽입하고 삭제하는일이 빈번할때 사용하는 것이 좋음
파이썬에서는 list가 Array로 구현되있고 동적배열을 사용해서 배열의 길이가 늘어나도 시간복잡도가 O(1)로 걸리도록 설계 되있음!! 링크드리스트 관련해선 공부가 더 필요할듯 백준 1158번 문제푸는데 꽤나 애먹었음.

#### Class
클래스는 분류나 집합 같은 속성과 기능을 총칭하는 개념!
객체는 유일무이한 사물이고 클래스는 그걸 아우르는 말이다. 그러니까 클래스 = 사람 이면 객체는 내가 될수도 있고 옆집 뒷집 등 다양한 사람들이 될 수 있는 것

#### 이진탐색
1~100중에서 특정 숫자를 찾아야 할 때 1부터 100까지 하나하나 다 찾아서 비교하는게 아니고 반 나눠서 업다운으로 비교하고 다시 반을 잘라서 비교하는 식으로 특정 숫자를 찾는 방식.
업다운 게임이랑 거의 동일함. 이게 순차적으로 찾는거보다 빅오표기법을 기반으로 봤을때 말도안되게 빨라지는듯

#### 재귀함수
재귀는 어떠한 것을 정의할 때 자기 자신을 참조하는 것을 말한다. 그니까 함수가 자기자신을 호출해서 쓰는 함수를 말함. 대표적으로 팩토리얼이랑 피보나치 등이 있음

### 6월 12일

#### 정렬
버블정렬, 선택 정렬, 삽입정렬, 병합정렬 다양하게 전체적인 개념들만 봄 병합정렬 개념이 중요하다고함

#### 스택(Stack)
후입선출(Last-in-First-out)구조로 직전의 행동 되돌릴때 사용하는 기능. (Ctrl+z)같이 굉장히 유용한 기능에도 스택이 쓰임 (선형구조)

#### 큐(Queue)
선입선출(First-in-First-Out)구조로 순서대로 처리되어야 하는일에 필요함. 주문 들어왔을때 순서대로 처리할경우 등등에 필요함 (선형구조)

#### 해쉬(Hash)
컴퓨팅에서 키를 값에 매핑할 수 있는 구조인 연관 배열 추가에 사용되는 자료구조. 해시 테이블 ->키와 데이터를 저장하고 즉작적으로 데이터를 받아오고 업데이트하고 싶을 때 사용하는 구조임.
해시 함수는 임의의 길이를 갖는 메세지를 입력하여 고정된 길이의 해쉬값을 출력하는 함수. 

#### 트리(Tree)
데이터가 계층적 혹은 망으로 구성되어 있으며 부모노드와 자식노드로 이어져 있는 자료구조. 트리 구조도 여러가지이지만 이진트리가 주로 쓰이는거 같음. 각노드가 최대 두개의 자식 노드를 가지는 구조로 되어있음(비선형구조)

#### 힙(Heap)
데이터에서 최대값과 최소값을 빠르게 찾기위해 고안된 완전 이진트리로 항상 큰값이 상위 레벨에 있고 작은 값이 하위 레벨에 있도록 하거나 작은 값이 가장위에 있고 큰값이 하위레벨에 있거나 두가지경우가 있음(Max 힙과 Min 힙)

#### 그래프(Graph)
연결관계에 초점이 맞춰진 구조. 노드와 간선으로 이루어져 있으며 유방향 그래프, 무방향그래프 두가지가 있다. 네이버 길찾기나 지하철 노선찾기 이런것도 다 그래프가지고 씀

#### DFS(Depth-First-Search) 와 BFS(Breadth-First-Search)
DFS(깊이 우선탐색)은 한노드를 시작으로 인접한 다른 노드를 재귀적으로 탐색해서 끝까지 탐색하고 나면 다시 위로 올라와서 탐색하는 구조. 스택이나 재귀함수로 구현하고 미로를 탐색할 때 한방향으로 끝까지 갔다가 다시 되돌아와서 다른방향으로 가면서 찾는거랑 비슷함.
BFS(너비우선탐색)은 노드의 모든 간선을 조회하면서 넘어감. 그니까 트리에서 레벨단위로 조사하면서 넘어가는 방식. 방문한 노드들을 차례로 저장한 후 꺼낼수 있는 구조인 큐를 사용한다. 노드의 인접한 부분부터 검사를 해나가기 시작하므로 길찾기같은 기능 쓸때 쓰임.
그리고 둘다 방문했던 노드는 확실하게 체크 해야댐 아니면 무한루프 돔

#### Dynamic Programming
복잡한 문제를 간단한 여러개의 문제로 나누어 푸는 방식을 말함. 즉, 여러개 하위 문제들 풀고 결과를 기록해놓은 다음 복잡한문제 풀때 하위문제들 푼걸 재활용해서 쌓아 올리는방식임. 피보나치를 예로들면 재귀함수 구현할려면 fibonacci(n) = fibonacci(n-2) + fibonacci(n-1)에서 n에 100 넣고 재귀함수하면 프로그램이 돌기만 하고 값을 안주는데 이게 연산이 너무 많아져서 그럼. 말하자면 10번째 수열 구하는데 9번째 8번째만 끌어오면 되는데 이 8번째 9번째 수열을 또 구할려고 되돌아가서 연산이 너무 많아지는것. 그래서 Dynamic Programming을 써서 8번째랑 9번째를 따로 값을 저장을 해두면 10번째구할때 다시 안되돌아가고 바로 끌어다 쓸수 있으니까 연산이 엄청나게 빨라짐. 


### 6월 14일 알고리즘 마라톤 시작
항해 99에서 알고리즘 마라톤 문제들중 1번부터 12번까지 12문제 완료 했다.
기본적인 사칙연산부터 for문 while문 문제부터 점화식 문제까지 있었는데 특히나 1011번 문제때문에 애를 많이 먹었다.
1011번 같은 경우 생각하다 안되서 직접 손으로 직접 써보고 계산해서 한 30번째까지 보다보니 규칙이 눈에 들어와서 어찌어찌 풀게 된거같다. 그리고 4948번 소수 n부터 2n째까지 구하는거 있었는데 그냥 구하던대로 소수 구하고 푸니까 시간초 오바나서 구글링하다 찾은 에라토스테네스의 체라는 방식을 공부하고 다시 풀어서 풀게 되었다. 보면 대부분 문제들을 어떻게 풀긴 푼거 같은데 걸리는 시간이 너무 오래 걸리는듯 하다. 알고리즘 문제풀때 한가지 방법으로 답이 나오면 넘어가는게 아니고 더 효율적인 방법도 한번 찾아볼 필요가 있을거 같다.


#### 6월 15일 알고리즘 마라톤 2일차  12문제 완료
알고리즘...오늘 하노이의 탑에 한두시간을 날렸는데도 결국 못풀었다. 재귀함수를 이용해서 푸는 알고리즘 방식인 것까지는 알겠는데 구현하는 방법을 모르겠다.  다른 기본적인 수학, 정수론, 조합론, 정렬과 이분탐색, 스택 관련문제들을 풀어봤다. 그리고 소수 구하는 방법인 에라토스테네스의 체는 알고리즘은 이해가가는데 구현법에서 약간 애매한 부분이 있는거 같음. 풀긴 풀었는데 뭔가 명확하게 이해한 느낌이 아닌듯 하다. 그리고 2805번 문제 이분탐색도 시간초과때문에 꽤나 애를 먹었는데 같은 코드인데도 함수를 선언하고 쓰냐 안쓰냐에 따라 달라지는지는 모르겠는데 아무튼 이분탐색 알고리즘을 함수로 선언하고 푸니까 시간초과가 안뜨긴 했는데 한번 다시 확인 해볼 필요가 있을듯. 나머지 문제들은 꽤나 무난하게 풀어 낸거같다.

#### 6월 16일 알고리즘 마라톤 3일차  8문제 완료
전체적으로 보면 기본적인 정수론, 수학같은건 무난하게 쉽게 푸는데 스택이나 큐 DFS, BFS의 응용분야로 가게 되면 구현 부분에서 굉장히 애를먹는다. 기본적인 개념 및 알고리즘 구현방법부터 다시 한번 천천히 살벼 볼 필요가 있음. 그리고 시간초과 이것때문에도 엄청 애먹었는데 알고리즘 문제에서 시간이 중요한 경우 기본 input 함수를 쓰는것보다 sys.stdin.readline을 써서 입력하는 것이 좋다. input()함수의 경우 사용자의 입력을 받고 문자열로 변환 후 추가 strip의 과정을 거치는 반면 sys.stdin.line의 경우 입력받는 버퍼를 한개만들어 그 버퍼에서 바로 읽어들이는 방식이라 속도면에서 차이가 많이난다. 그냥 값 몇개 받는데 그리 차이가 나냐고 생각할 수도 있지만 그 단위가 10만이나 그 이상의 수가 되면 입력당 그이상의 시간이 차이가 나게 되는 것이다. 18258번도 시간초과 때문에 애를 많이 먹었는데 바꿔가면서 했는데 6번인가 실패하고 나서 deque라는 함수를 찾아보고 이용해서 맞췄다. 이게 큐에서 pop을 구현할때 그냥 리스트의 첫번째 요소를 빼면은 나머지 요소들이 앞으로 한칸씩 떙겨지는걸 연산하는데 걸리는 시간이 어마어마 했던거 같다. 그래서 popleft를 이용해보니 시간초과없이 통과했다.
 
#### 6월 17일 알고리즘 마라톤 4일차 6문제 완료
난이도가 있는 문제들을 다루다보니 문제푸는데 시간이 엄청 오래걸린다. 먼저 1002번은 생각보다 간단한 문제였는데 예외처리를 생각안하고 하나씩 추가하다가 오래걸렸다. 결국 노트에 글로써서 내접, 외접, 겹칠때 안겹칠때 등등 케이스를 다 나눠서 풀었다. 1260번은 DFS, BFS를 각각 stack과 queue를 통해 구현하는법을 공부한 후 해결함. 15650번은 처음에 하나하나 다 따져가면서 풀다보니 시간초과가 계속 났었다. 그래서 백트레킹 알고리즘이란걸 찾아보고 공부한 후 dfs탐색과 백트레킹을 이용해 풀었다. 그 이후에 다른걸 찾아보니 파이썬에 라이브러리 함수로 조합도 쓸수 있어서 두가지 방법으로 풀어봄. 2630번은 분할정복을 이용해 푸는 문제인데 감이 잘안잡혀서 다시 공부후 도전예정

#### 6월 18일 알고리즘 마라톤 5일차 41번 문제까지 완료
어제 못 풀었던 2630번은 결국 트루스포스 형태에 가깝게 4사분면을 나누고 또 나눠서 파고들어가는 형태로 해서 풀었다. 그리고 백트레킹중 가장 어렵고 이해가 잘안되는 9663번..풀긴 풀었는데 파이썬으로는 아무리해도 시간초과가 떠서 pypy로 풀어서 냈다. 분할정복이라기엔 거의 모든 점을 다 탐색해가며 푼 느낌이 강해서 다른 방법이 있으면 한번 더 찾아서 공부해봐야 될듯하다. 40번까진 전부 완료했으니 한번 다시 풀어보고 적용한 알고리즘들을 정리 해볼 필요가 있을거같음.

#### 6월 19일 알고리즘 마로톤 6일차 7문제 50번까지 46, 47번제외
전체적으로 이제 조금씩 어떤식으로 알고리즘 구현을 해야되는지 살짝 잡히기 시작하긴 하는데 시간초과때문에 수정을 하느라 시간이 너무 오래 걸린다. 탐색알고리즘 문제들이나 점화식문제들을 많이 다뤄보고 풀어봐야 할거같음.
그리고 다이나믹 프로그래밍 문제들은 쉬운거부터 하나하나 풀어봐야 감이 좀더 잡힐거같다 46, 47번 둘다 메모이제이션 문제로 보이는데 구현하는 방법이 잘 생각이 안나서 고민만하고 잘 못풀게됨.

#### 6월 21일 알고리즘 마라톤 8일차
난이도있는 문제들을 풀다 보니 DFS, BFS, DP, 이분탐색문제에서 계속 응용을 못하고 막혀서 문제푸는 걸 잠시 다시 스탑하고 기본적인 개념부터 쉬운문제들을 다시 한번 다뤄봐야 될거같아서 알고리즘은 문제풀이는 잠시 멈추고 리액트를 이제 배울 예정이기 때문에 기본적인 js의 기본적인 문법들을 익히고 공부했다. 

#### 6월 22일 알고리즘 마라톤 9일차
알고리즘들 중에 DFS, BFS, DP, 이분탐색과 분할정복의 기본 개념들을 다시한번 익히고 코드로 구현해봤다. 그리고 알고리즘 마라톤 문제 풀었던 문제들을 1~30번까지 다시 한번 풀어보는데 처음에 풀던 것처럼 그냥 마구잡이로 푸는것이 아니라 노트에 직접 어떤 자료형을 쓰고 어떤 변수를 써서 어떤순서로 구현을 할건지 세세하게 적어보고 구현을 해봤다. 확실히 기존처럼 그냥 바로 풀이에 뛰어들때보다 논리적으로 접근 할수 있었고 다시 풀어도 잘 이해가 안됫던 문제들도 이제 확실히 풀 수 있게 된거 같다. 이제 각 유형별 문제를 한개씩 다 풀어보면서 익혀나가면 될 듯하다.

#### 6월 23일 알고리즘 마라톤 10일차(마지막날)
오늘은 31~ 40번 문제들 한번씩 다시 다 풀어봤고 이분탐색과 DFS, BFS관련 문제들이 계속 막히고 잘 안풀려서 그에 관한 개념들만 다시 정리하고 이분탐색 문제를 따로 찾아서 몇문제 다뤄보고 풀어봤다. 알고리즘 마라톤은 마지막날이긴 하지만 앞으로 일주일에 몇문제 정해놓고 계속해서 풀어봐야 안까먹고 기억할듯함. 특히 알고리즘 문제로 주로 나오는 개념들은 이번주에 velog에 상세하게 정리해서 넣어 놓을 예정이다.

#### 6월 24일 주특기주차 준비
자바 스크립트 기본문법 강의를 한번 전체적으로 듣고 자바스크립트 사이트에서 기본문법들 전체적으로 다시 점검 후 리액트 공식사이트에 들어가서 어떤식으로 동작하는지 한번 다 읽어봤다. 
#### 6월 25일 리액트 시작
기본 환경설정부터 시작해서 JSX 사용법을 익히고 컴포넌트를 간단하게 다루는법 및 리액트에서 css사용법을 배웠다. 그리고 scss 및 styled-components 문법 및 생명주기 함수 가상돔에 관한 강의를 들음.
돔이란 것은 html 단위 하나하나를 객체로 생각하는 모델인데 div라는 객체가 있으면 그 안에 하위값으로 텍스트노드 자식노드 등 여러가지 값을가진 트리구조로 이루어져 있다. 그런데 여기서 html 하나가 수정될때마다 모든 객체가 다 수정된다면 필요없는 연산이 너무 많아지게되서 등장한 것이 가상돔이라고 한다. 기존의 돔에서 비교해서 바뀐부분만 갈아끼워넣는 방식이기 때문에 업데이트 처리가 굉장히 간결하다. 그리고 컴포넌트의 라이프사이클은 개념이 있는데 컴포넌트가 렌더링을 준비하는 순간부터, 페이지에서 사라질 때까지가 라이프 사이클이다. 위 두개념은 공식문서에서 조금 더 보고 함수를 다양하게 써서 몇개 더 구현해봐야 확실히 이해가 갈듯함.
#### 6월 26~27일 리액트 강의 4주차까지 수강 완료 및 과제 틀 만들기
리액트에서 라우팅 처리 하는 법 및 리덕스를 이용해 리액트 상태관리 하는방법을 배우고 컴포넌트에서 리덕스데이터를 사용하는 방법을 배웠다. 먼저 라우팅은 브라우저 주소에 따라 다른페이지를 보여주는 것인데, 리액트의 경우 SPA라서 html을 딱 하나가지고 있지만 react-route-dom 패키지를 이용해 주소창대로 다른 페이지를 보여 줄순 있다. 리덕스는 데이터를 한군데에 몰아 넣고 여기저기에 꺼내볼수 있게 만들어주는 것이다. 리액트 각각의 컴포넌트들에서 끌어다 쓸수있는 전역상태관리??그런 개념인거 같다. 리덕스 store를 컴포넌트에 연결하고 컴포넌트의 상태변화가 필요할때 action을 불러서 reducer를 통해 새로운 상태값을 만든 것을 store에 저장하고 컴포넌트는 새로운 상태값을 받아오는 흐름으로 되어 있다. 각각 컴포넌트에 데이터를 만들고 넘겨줄 필요없이 각 컴포넌트들이 리덕스스토어를 이용해 데이터를 쓰고 지울수 있는식으로 동작한다. 오늘 리액트를 배우고 써보면서 드는 생각인데 동작하는 방식이나 데이터를 넘겨주고 받는거는 잘 되는데 css파트에 관한 부분이 학습이 더 필요할거같다.
#### 6월 28일 리액트 강의 수강 완료및 나만의 사전 과제 시작
리액트에서 firebase 연동법 및 리덕스에서 firestore 데이터 이용방법에 관한 강의를 집중적으로 수강했다. 그리고 과제 진행중에 input값 3개를 ref로 관리하라는 항목이 있었는데 이게 아무리 해도 오류를 잡을 수가 없어서 공식문서를 계속 읽어봤는데 ref는 특정영역에서 사용되는것 같고 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리하거나 애니메이션을 직접 실행할때 혹은 서드파티 DOM라이브러리를 React와 같이 사용할때 라고 되있다. 보면 특정 값을 받아오거나 포커스를 줄때 사용하는 함수 같아서 일단 3개 input값을 동시에 받아야되니까 useState를 이용해서 값을 받아오는 코드로 바꿔서 만들었다. Ref의 개념 및 DOM구조에 대한건 프로젝트 끝난이후 조금더 공부가 필요할듯 하다.

#### 6월 29일 리액트 나만의 사전 과제 완료
과제에서 요구하는 조건들인 게시글 목록 화면에 그리기, 게시글 내의 예시는 파란색, 게시글 목록 리덕스에서 관리 및 목록 firestore에서 가져오기 완료 및 게시글 작성에서 input3개 관리 및 리덕스에 추가 그리고 firestore에 저장까지 다 완료 했고 WordData 컴포넌트를 만들어서 데이터를 따로 삭제 할수 있는 버튼을 추가했고 예시를 추가로 업데이트 할 수 있는 기능을 추가 구현중임. 데이터를 삭제하는과정에서 조금 오래 걸렸는데 firebase데이터들은 삭제할때 각 객체 혹은 콜렉션의 id값이 있어야 삭제를 할수 있다. 그래서 애초에 파이어스토어에서 데이터를 불러올때 아이디값을 넣어서 불러오는 방법으로 코드를 바꿔서 데이터를 삭제할수 있게 했다. 

#### 7월 2일 리액트 심화과정 수강 시작
리액트 화면 페이지 구성할때 컴포넌트를 잘게 엘리먼트 단위까지 쪼개서 화면을 구성하는 내용인데 리액트는 컴포넌트를 재사용하기를 좋아해서 데이터의 불변성 때문에 버튼하나하나 까지 잘게 쪼개서 넣어놓는거 같다. 그리고 로그인을 리덕스와 토큰(쿠키)를 이용해서 구현하는 방법에 대해 배움. 그리고 promise객체가 비동기 연산이 종료된 이후 결과를 알기위해 사용하는 객체라는데 비동기 작업 및 promise, promise chaining, async await에 관해선 조금 더 개념에 대한 이해가 필요할듯
