# TIL

### 6월 11일

#### 점근적 복잡도
시간 복잡도와 공간복잡도에 관해 배움. 시간복잡도는 간략하게 말하면 입력값과 문제를 해결하는데 걸리는 시간과의 상관관계를 말하고, 공간 복잡도는 입력값과 문제를 해결하는 데 걸리는 공간과의 상관관계를 말함.
시간복잡도를 대체로 더 중요하게 여기고 입력값이 많아져도 걸리는 시간이 덜 늘어나는 알고리즘이 좋은 알고리즘이 될 수 있다고 함. 아닐수도 있고

#### Array | Linked List
Array는 배열이고 특정 원소를 조회하는 경우에 사용하는 것이 유리하고 LinkedList는 중간에 데이터를 삽입하고 삭제하는일이 빈번할때 사용하는 것이 좋음
파이썬에서는 list가 Array로 구현되있고 동적배열을 사용해서 배열의 길이가 늘어나도 시간복잡도가 O(1)로 걸리도록 설계 되있음!! 링크드리스트 관련해선 공부가 더 필요할듯 백준 1158번 문제푸는데 꽤나 애먹었음.

#### Class
클래스는 분류나 집합 같은 속성과 기능을 총칭하는 개념!
객체는 유일무이한 사물이고 클래스는 그걸 아우르는 말이다. 그러니까 클래스 = 사람 이면 객체는 내가 될수도 있고 옆집 뒷집 등 다양한 사람들이 될 수 있는 것

#### 이진탐색
1~100중에서 특정 숫자를 찾아야 할 때 1부터 100까지 하나하나 다 찾아서 비교하는게 아니고 반 나눠서 업다운으로 비교하고 다시 반을 잘라서 비교하는 식으로 특정 숫자를 찾는 방식.
업다운 게임이랑 거의 동일함. 이게 순차적으로 찾는거보다 빅오표기법을 기반으로 봤을때 말도안되게 빨라지는듯

#### 재귀함수
재귀는 어떠한 것을 정의할 때 자기 자신을 참조하는 것을 말한다. 그니까 함수가 자기자신을 호출해서 쓰는 함수를 말함. 대표적으로 팩토리얼이랑 피보나치 등이 있음

### 6월 12일

#### 정렬
버블정렬, 선택 정렬, 삽입정렬, 병합정렬 다양하게 전체적인 개념들만 봄 병합정렬 개념이 중요하다고함

#### 스택(Stack)
후입선출(Last-in-First-out)구조로 직전의 행동 되돌릴때 사용하는 기능. (Ctrl+z)같이 굉장히 유용한 기능에도 스택이 쓰임 (선형구조)

#### 큐(Queue)
선입선출(First-in-First-Out)구조로 순서대로 처리되어야 하는일에 필요함. 주문 들어왔을때 순서대로 처리할경우 등등에 필요함 (선형구조)

#### 해쉬(Hash)
컴퓨팅에서 키를 값에 매핑할 수 있는 구조인 연관 배열 추가에 사용되는 자료구조. 해시 테이블 ->키와 데이터를 저장하고 즉작적으로 데이터를 받아오고 업데이트하고 싶을 때 사용하는 구조임.
해시 함수는 임의의 길이를 갖는 메세지를 입력하여 고정된 길이의 해쉬값을 출력하는 함수. 

#### 트리(Tree)
데이터가 계층적 혹은 망으로 구성되어 있으며 부모노드와 자식노드로 이어져 있는 자료구조. 트리 구조도 여러가지이지만 이진트리가 주로 쓰이는거 같음. 각노드가 최대 두개의 자식 노드를 가지는 구조로 되어있음(비선형구조)

#### 힙(Heap)
데이터에서 최대값과 최소값을 빠르게 찾기위해 고안된 완전 이진트리로 항상 큰값이 상위 레벨에 있고 작은 값이 하위 레벨에 있도록 하거나 작은 값이 가장위에 있고 큰값이 하위레벨에 있거나 두가지경우가 있음(Max 힙과 Min 힙)

#### 그래프(Graph)
연결관계에 초점이 맞춰진 구조. 노드와 간선으로 이루어져 있으며 유방향 그래프, 무방향그래프 두가지가 있다. 네이버 길찾기나 지하철 노선찾기 이런것도 다 그래프가지고 씀

#### DFS(Depth-First-Search) 와 BFS(Breadth-First-Search)
DFS(깊이 우선탐색)은 한노드를 시작으로 인접한 다른 노드를 재귀적으로 탐색해서 끝까지 탐색하고 나면 다시 위로 올라와서 탐색하는 구조. 스택이나 재귀함수로 구현하고 미로를 탐색할 때 한방향으로 끝까지 갔다가 다시 되돌아와서 다른방향으로 가면서 찾는거랑 비슷함.
BFS(너비우선탐색)은 노드의 모든 간선을 조회하면서 넘어감. 그니까 트리에서 레벨단위로 조사하면서 넘어가는 방식. 방문한 노드들을 차례로 저장한 후 꺼낼수 있는 구조인 큐를 사용한다. 노드의 인접한 부분부터 검사를 해나가기 시작하므로 길찾기같은 기능 쓸때 쓰임.
그리고 둘다 방문했던 노드는 확실하게 체크 해야댐 아니면 무한루프 돔

#### Dynamic Programming
복잡한 문제를 간단한 여러개의 문제로 나누어 푸는 방식을 말함. 즉, 여러개 하위 문제들 풀고 결과를 기록해놓은 다음 복잡한문제 풀때 하위문제들 푼걸 재활용해서 쌓아 올리는방식임. 피보나치를 예로들면 재귀함수 구현할려면 fibonacci(n) = fibonacci(n-2) + fibonacci(n-1)에서 n에 100 넣고 재귀함수하면 프로그램이 돌기만 하고 값을 안주는데 이게 연산이 너무 많아져서 그럼. 말하자면 10번째 수열 구하는데 9번째 8번째만 끌어오면 되는데 이 8번째 9번째 수열을 또 구할려고 되돌아가서 연산이 너무 많아지는것. 그래서 Dynamic Programming을 써서 8번째랑 9번째를 따로 값을 저장을 해두면 10번째구할때 다시 안되돌아가고 바로 끌어다 쓸수 있으니까 연산이 엄청나게 빨라짐. 


### 6월 14일 알고리즘 마라톤 시작
항해 99에서 알고리즘 마라톤 문제들중 1번부터 12번까지 12문제 완료 했다.
기본적인 사칙연산부터 for문 while문 문제부터 점화식 문제까지 있었는데 특히나 1011번 문제때문에 애를 많이 먹었다.
1011번 같은 경우 생각하다 안되서 직접 손으로 직접 써보고 계산해서 한 30번째까지 보다보니 규칙이 눈에 들어와서 어찌어찌 풀게 된거같다. 그리고 4948번 소수 n부터 2n째까지 구하는거 있었는데 그냥 구하던대로 소수 구하고 푸니까 시간초 오바나서 구글링하다 찾은 에라토스테네스의 체라는 방식을 공부하고 다시 풀어서 풀게 되었다. 보면 대부분 문제들을 어떻게 풀긴 푼거 같은데 걸리는 시간이 너무 오래 걸리는듯 하다. 알고리즘 문제풀때 한가지 방법으로 답이 나오면 넘어가는게 아니고 더 효율적인 방법도 한번 찾아볼 필요가 있을거 같다.


#### 6월 15일 알고리즘 마라톤 2일차  12문제 완료
알고리즘...오늘 하노이의 탑에 한두시간을 날렸는데도 결국 못풀었다. 재귀함수를 이용해서 푸는 알고리즘 방식인 것까지는 알겠는데 구현하는 방법을 모르겠다.  다른 기본적인 수학, 정수론, 조합론, 정렬과 이분탐색, 스택 관련문제들을 풀어봤다. 그리고 소수 구하는 방법인 에라토스테네스의 체는 알고리즘은 이해가가는데 구현법에서 약간 애매한 부분이 있는거 같음. 풀긴 풀었는데 뭔가 명확하게 이해한 느낌이 아닌듯 하다. 그리고 2805번 문제 이분탐색도 시간초과때문에 꽤나 애를 먹었는데 같은 코드인데도 함수를 선언하고 쓰냐 안쓰냐에 따라 달라지는지는 모르겠는데 아무튼 이분탐색 알고리즘을 함수로 선언하고 푸니까 시간초과가 안뜨긴 했는데 한번 다시 확인 해볼 필요가 있을듯. 나머지 문제들은 꽤나 무난하게 풀어 낸거같다.

#### 6월 16일 알고리즘 마라톤 3일차  8문제 완료
전체적으로 보면 기본적인 정수론, 수학같은건 무난하게 쉽게 푸는데 스택이나 큐 DFS, BFS의 응용분야로 가게 되면 구현 부분에서 굉장히 애를먹는다. 기본적인 개념 및 알고리즘 구현방법부터 다시 한번 천천히 살벼 볼 필요가 있음. 그리고 시간초과 이것때문에도 엄청 애먹었는데 알고리즘 문제에서 시간이 중요한 경우 기본 input 함수를 쓰는것보다 sys.stdin.readline을 써서 입력하는 것이 좋다. input()함수의 경우 사용자의 입력을 받고 문자열로 변환 후 추가 strip의 과정을 거치는 반면 sys.stdin.line의 경우 입력받는 버퍼를 한개만들어 그 버퍼에서 바로 읽어들이는 방식이라 속도면에서 차이가 많이난다. 그냥 값 몇개 받는데 그리 차이가 나냐고 생각할 수도 있지만 그 단위가 10만이나 그 이상의 수가 되면 입력당 그이상의 시간이 차이가 나게 되는 것이다. 18258번도 시간초과 때문에 애를 많이 먹었는데 바꿔가면서 했는데 6번인가 실패하고 나서 deque라는 함수를 찾아보고 이용해서 맞췄다. 이게 큐에서 pop을 구현할때 그냥 리스트의 첫번째 요소를 빼면은 나머지 요소들이 앞으로 한칸씩 떙겨지는걸 연산하는데 걸리는 시간이 어마어마 했던거 같다. 그래서 popleft를 이용해보니 시간초과없이 통과했다.
 
#### 6월 17일 알고리즘 마라톤 4일차 6문제 완료
난이도가 있는 문제들을 다루다보니 문제푸는데 시간이 엄청 오래걸린다. 먼저 1002번은 생각보다 간단한 문제였는데 예외처리를 생각안하고 하나씩 추가하다가 오래걸렸다. 결국 노트에 글로써서 내접, 외접, 겹칠때 안겹칠때 등등 케이스를 다 나눠서 풀었다. 1260번은 DFS, BFS를 각각 stack과 queue를 통해 구현하는법을 공부한 후 해결함. 15650번은 처음에 하나하나 다 따져가면서 풀다보니 시간초과가 계속 났었다. 그래서 백트레킹 알고리즘이란걸 찾아보고 공부한 후 dfs탐색과 백트레킹을 이용해 풀었다. 그 이후에 다른걸 찾아보니 파이썬에 라이브러리 함수로 조합도 쓸수 있어서 두가지 방법으로 풀어봄. 2630번은 분할정복을 이용해 푸는 문제인데 감이 잘안잡혀서 다시 공부후 도전예정

#### 6월 18일 알고리즘 마라톤 5일차 41번 문제까지 완료
어제 못 풀었던 2630번은 결국 트루스포스 형태에 가깝게 4사분면을 나누고 또 나눠서 파고들어가는 형태로 해서 풀었다. 그리고 백트레킹중 가장 어렵고 이해가 잘안되는 9663번..풀긴 풀었는데 파이썬으로는 아무리해도 시간초과가 떠서 pypy로 풀어서 냈다. 분할정복이라기엔 거의 모든 점을 다 탐색해가며 푼 느낌이 강해서 다른 방법이 있으면 한번 더 찾아서 공부해봐야 될듯하다. 40번까진 전부 완료했으니 한번 다시 풀어보고 적용한 알고리즘들을 정리 해볼 필요가 있을거같음.

#### 6월 19일 알고리즘 마로톤 6일차 7문제 50번까지 46, 47번제외
전체적으로 이제 조금씩 어떤식으로 알고리즘 구현을 해야되는지 살짝 잡히기 시작하긴 하는데 시간초과때문에 수정을 하느라 시간이 너무 오래 걸린다. 탐색알고리즘 문제들이나 점화식문제들을 많이 다뤄보고 풀어봐야 할거같음.
그리고 다이나믹 프로그래밍 문제들은 쉬운거부터 하나하나 풀어봐야 감이 좀더 잡힐거같다 46, 47번 둘다 메모이제이션 문제로 보이는데 구현하는 방법이 잘 생각이 안나서 고민만하고 잘 못풀게됨.
